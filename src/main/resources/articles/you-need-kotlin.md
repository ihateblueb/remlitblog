## Introduction

The title is a little absurd, I know, I thought it was funny.

I picked up Kotlin in the summer of this year to try and get my project [Aster](https://github.com/ihateblueb/aster) back and running, and it's become
my language. If it can be written in Kotlin, I try to write it in Kotlin. This web page you're looking at is being
served by the Kotlin HTTP framework, and the layout HTML was generated by the Kotlin HTML DSL<sup>[1]</sup>, and the markdown file
was turned to HTML by the Jetbrains Markdown library in Kotlin. The CSS could be Kotlin, too, but that feels a little
absurd.

Anyway, this illustrates my point that I love this language and know a lot about it. This article serves to host all
my current thoughts and love for this language (and maybe to convince others to try it).

## Syntax & Quirks

Kotlin's known for being more concise Java (and The Android Language). It's genuinely one of it's best features, there's
no other language that fully matches what makes Kotlin's syntax so great. 

Kotlin requires no semicolons, which was a small adaptation I had to make originally. I came from TypeScript which doesn't require
them, but I always had them enabled for my projects so it became automatic for me. Now I have the reverse problem where I don't
remember to use semicolons in Java. You can still use them when you have to, like here:

```kotlin
print("One thing and "); println("another thing")
```

// TODO: it and this, apply, let, etc

### ?. and ?:

Most of the time, I can fold a lot of my null checking into an elvis operator (`?:`). For example:

```kotlin
UserService.getById(id) ?: throw Exception("User couldn't be found")
```

But in Java, I'd have to do all this...

```java
User user = UserService.getById(id);

if (Objects.isNull(user)) {
    throw new Exception("User couldn't be found");
}
```

### Ternary

Kotlin does not have a ternary (`condition ? true : false`) but instead recommends using inline if statements.
(`if (condition) true else false`). I don't feel very strongly about this, but I do tend to lean towards agreeing with
the Kotlin devs that it makes code more readable. Having too many random symbols can quickly make an easy to catch
condition problem unrecognizable in `? :` soup.

### String Templating

Kotlin is big on string templating. Whenever you can, it's generally suggested, and it saves a lot of space.

```kotlin
println("It is currently $time in $timezone")
// rather than
println("It is currently " + time + " in " + timezone)
```

### Function Equals

In Kotlin, you can set a function as equal to a value.

```kotlin
fun findCat() = "üêà"
```

This is equivalent to if I had written `return "üêà"` in the body of the function. I can also set this equal
to another function and pass the parameters.

```kotlin
fun findCat(id: String) = CatService.find(id)
```

### Variables

Kotlin has three main variables, `const val`, `val`, and `var`. `const val` is like final properties, they're final at
compile time. `val` is a property that cannot be reassigned, but can change. `var` is a property that can be reassigned.
Something I've never loved about Java and other languages were the types being the start of a variable. I understand
strict typing when you're setting properties on a class, but when it's just a random variable in a function then it feels
a little overkill. That's why Kotlin doesn't suggest adding types to variables unless theyre const, or properties of some
object.

```kotlin
class Dog {
	val type: DogType = DogType.Loud // Suggested
}

fun dog() {
	val dogs = DogService.getAll() // Not needed, inline type in your IDE will show it to you instead
}
```

Automatically, getters and setters are generated for Java interop, but they can be set specifically like this:

```kotlin
var test get() = Config.get("value")
    set(value) = Config.write("value", value)
```

### Goodbye .getThing()

Kotlin automatically maps getters and setters to a val or var. If you're using a Java library, like Bukkit, then
automatically you can do:

```kotlin
val pluginManager = this.server.pluginManager
// instead of...
val pluginManager = this.getServer().getPluginManager()
```

This is one of many things that helps Kotlin be more concise and easier on the eyes. 

### Return Labelling

Kotlin loves lambdas (more on that later), so sometimes your code can get messy fast. Where you are returning to can also
get messy. Kotlin's thought of this though, and has return labels.

```kotlin
fun getFirstColor(exclude: Color) = transaction {
	db.getAvailableColors().forEach {
		if (it == exclude) return@forEach // equivalent to continue
		else return@transaction it // returns to outside of this loop
	}
} 
```

// TODO: Read return labelling docs, maybe get a return@loop example or some other special one. Or show how to set specific labels.

## Data Classes

Record classes are not the same

## Extension Functions

Extension functions are a big part of Kotlin, Ktor<sup>[2]</sup> is mostly based around them. Extension functions are when
you extend a class by specifying it in front of your function method. 

```kotlin
fun Application.module() {}
```

This function extends the Application class, and is now available like a method and just as `module()` in the current file.

My biggest use case for this was when I moved all my common API responses to a shared project that could be used for multiple
platforms. I used to have the database entity -> API response convertor functions on the companion objects of the data classes.
So, when I moved them to the common project, the database entity classes were no longer available and I had to move the
convertors to an extension function, like this:

```kotlin
fun Invite.Companion.fromEntity(entity: InviteEntity): Invite = Invite(
    id = entity.id.toString(),
    code = entity.code,
    // ...
    createdAt = entity.createdAt,
    usedAt = entity.usedAt
)
```

// Research: Java Interop
This extends the companion object so it's available like a static. I'll have more to say about those later on.

## Lambda Parameters

Kotlin loves lambdas, and the many DSLs<sup>[1]</sup> made in Kotlin use them in parameters. For example:

```kotlin
main {
    h1 {
        +"HTML DSL Example"
    }
    p {
        +"Hello! This is all inline functions!"
    }
}
```

...and in Gradle Kotlin configurations:

```kotlin
plugins {
    kotlin("jvm")
}

group = "site.remlit"
version = "0.0.1"

dependencies {}
```

I'm a big fan of these. In Aster, I have an event system that relies a lot on lambdas being passed to an event registry
where they're stored and then later called upon an event happening.

## Inline Functions

Inline functions are like regular functions, but often have lambda parameters. They can come with a performance benefit. 
In certain cases, it's more performant to inline the code than force an object to be created for the function. I say in 
certain cases because if you aren't careful, or have very large inline functions, you'll have excessive duplicates in 
compiled code that counteract the benefit inline functions are supposed to bring.

A simple example inline function:

```kotlin
inline fun paragraph(text: () -> String) =
    "<p>${text()}</p>"

// can be used like
paragraph { "These small creatures inhabit Skyloft." }

// and results in <p>These small creatures inhabit Skyloft.</p>
```

Inline functions also are the only to support reified type parameters which allow you to inspect the passed type in your 
code. For example:

```kotlin
inline fun <reified T> speak() =
    when (T) {
        is Cat -> "Meow"
        is Dog -> "Bark"
        else -> "AAAAH!"
    }
```

Where if the type parameter isn't reified...

```kotlin
inline fun <T> speak() =
    when (T) { // Error: Type parameter 'T' is not an expression.
        is Cat -> "Meow"
        is Dog -> "Bark"
        else -> "AAAAH!"
    }
```

// todo: noinline, crossinline

## Infix Functions

Infix functions are probably one of my favorite Kotlin features. They seem weird to begin with, but once you see how
they're used by others they feel very clever.

For example, Jetbrains Exposed (the Kotlin ORM) uses them to build query strings:

```kotlin
UserEntity
    .find {
        UserTable.host eq null and // eq, and are infix
        (UserTable.username neq "instance.actor") and // neq, and
        (UserTable.createdAt lessThan TimeService.now()) // lessThan 
    }
    .toList()
```

Another example is my math project I wrote for Set Theory:

```kotlin
println(a isDisjoint b)
println(a union (c complement u))
println(a intersection b intersection c)
println((h intersection k) diff j complement u)
println((a complement u) intersection (b complement u))
```

They let you write natural feeling code that just flows and is easily fit anywhere, and I love that.

## Trying to be Functional

Kotlin tries to appeal to people who like functional programming. At least a little bit.

## Coroutines

// Research

Only recently have I started really working with coroutines where I need to know everything about how they work. My first
impression wasn't positive though, I just thought "Oh, this is annoying." Now that I've actually had to use them, I
am alright with them. I like that they are more efficient with thread usage, which generally helps large scale servers
like Aster run butter than if they were in Java.

Coroutines start off at a dispatcher, and then the `suspend` (async) task is sent off to an available worker.

## Serialization

Kotlin serialization has been wonderful for my use case. I only had one hiccup when it came to ActivityPub's `object` property
which can be either an object or the ID of an object. For the most part, it's write a data class, throw on `@Serializable`,
and you're good to go. It's fast too, even with my weird rules and custom serializer.

## Multiplatform

I never really wanted to touch KMP, but in Aster I was able to move a bunch of my data classes for common objects compile
to a TypeScript library and be used in Kotlin. It's been nice to have types in the frontend exactly as they are in the
backend.

## Objects

One of my biggest annoyances with Kotlin is the lack of statics. Instead, it has objects and companion objects. Objects
work like a Java class with all statics would, and companion objects act like an embedded all static class.

So, these:

```kotlin
object Bookshelf {
    val books = mutableListOf<Book>()
    fun tipOver() {}
}
```

```kotlin
class Book {
    fun read() {}
    
    companion object {
	    fun create() {}
    }
} 
```

...are equivalent to these:

```java
class Bookshelf {
    public static List<Book> books = new List<Book>();
    public static void tipOver() {}
}
```

```java
class Book {
    public void read() {}

    static class Companion {
        public static Book create() {}
    }
}
```

I think the generated Companion subclass is unbelievably ugly and annoying.

This can be fixed with `@JvmStatic`. With this annotation, static methods are generated alongside the companion object.
Still, it's just a patch on default annoying behaviour. Having objects is not something I'm against, but if it's at the
cost of statics in classes, I'm not a big fan.

This is an issue that's been debated for years, has had multiple KEEP<sup>[3]</sup> discussions, and may or may not be
resolved eventually. For now, I'm fine with the language as is. This is my only major complaint, and it'd be less of a
thing for me if I was willing to make all my Service classes in Aster objects to begin with. It just feels weird to make
them objects. Overall, it is not a big deal.

## IDE Choices

Since Kotlin was made by Jetbrains, it's only really been supported in IntelliJ IDEA. It's had an Eclipse plugin for a
while, but it was basically unusable when I tested it. Recently, Jetbrains has been trying to fix this, and they've made
great progress. There's a [Visual Studio Code extension](https://github.com/Kotlin/kotlin-lsp) that I haven't used much
and also an extension for [Zed](https://zed.dev/extensions/kotlin) that works alright. I still use IDEA when I can,
even on my laptop where it's pretty terrible to use, but they're making progress.

## Honorable Mentions

### Cool Annotations

There's a bunch of built-in annotations for the JVM target that sound cool, but I never end up using them. One example of
that is `@JvmSynthetic` which makes it so only Kotlin code can use the annotated method. There's also `@JvmName`,
`@JvmField`, `@JvmDefault`, and others. Sometimes there's annotations to make up for missing features, like `@Throws`,
which is like Java's throws.

### Context Parameters

// TODO: https://kotlinlang.org/docs/whatsnew22.html#preview-of-context-parameters

### Kotlin Scripting

Gradle

### Smart Casting

It's very rare I end up having to cast a value to a type. Kotlin's smart casting catches almost everything I've needed it
to, which is generally what I expect a programming language with casts to do. After using Swift breifly before Kotlin, it feels
neccesary to mention how much it isn't like Swift. You can read more about it [here](https://kotlinlang.org/docs/typecasts.html#smart-casts).

### Primitive Types

Unlike Java, primitive types aren't lowercased. This is purely aesthetics, but genuinely I've always hated putting a lowercase
type after a colon in Java.

### Nothing Beats Duke

Like most programming languages, Kotlin has a mascot. It's name is Kodee, and it looks super weird, but I've come around to liking
it. I'm not loving Duke any less though.

![Kodee waving at the viewer and winking](/static/img/kodeewave.webp)

## The Android Language

Kotlin has way more potential than being just "The Android Language," and I hope it becomes more adopted. It's a wonderful
language to write, and has so many libraries and resources available just by having such strong Java interop. If you've been
interested in anything mentioned here, you should [try it out](https://kotlinlang.org/docs/jvm-get-started.html)!

If you want to look at real Kotlin code, you can check out [Aster](https://github.com/ihateblueb/aster-kt), or [this blog's backend](https://github.com/ihateblueb/remlitblog),
or a variety of other open source Kotlin projects on [GitHub](https://github.com/search?q=language%3AKotlin&type=repositories) or [Codeberg](https://codeberg.org/explore/repos?q=&language=Kotlin).

Also, if you liked reading this, let me know. I liked writing it a lot and plan to write more in depth about specific Kotlin
features in the future.

## Footnotes

**1:** Domain Specific Language, referring to Kotlin's ability to make what feels like a custom language with inline and
infix functions.

**2:** The Kotlin HTTP framework, https://ktor.io/

**3:** Kotlin Evolution and Enhancement Process, the Kotlin JEP equivalent
