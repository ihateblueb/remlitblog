## Introduction

The title is a little absurd, I know, I thought it was funny.

I picked up Kotlin in the summer of this year to try and get my project [Aster](https://github.com/ihateblueb/aster) back and running, and it's become
my language. If it can be written in Kotlin, I try to write it in Kotlin. This web page you're looking at is being
served by the Kotlin HTTP framework, and the layout HTML was generated by the Kotlin HTML DSL<sup>[1]</sup>, and the markdown file
was turned to HTML by the Jetbrains Markdown library in Kotlin. The CSS could be Kotlin, too, but that feels a little
absurd.

Anyway, this illustrates my point that I love this language and know a lot about it. This article serves to host all
my thoughts and love for this language (and maybe to convince others to try it).

## Syntax & Quirks

Kotlin's known for being more concise Java (and The Android Language)

// TODO: Iterators, it and this, apply, let, etc. return@

### ?. and ?:

Most of the time, I can fold a lot of my null checking into an elvis operator (`?:`). For example:

```kotlin
UserService.getById(id) ?: throw Exception("User couldn't be found")
```

But in Java, I'd have to do all this...

```java
User user = UserService.getById(id);

if (Objects.isNull(user)) {
    throw new Exception("User couldn't be found");
}
```

### Ternary

Kotlin does not have a ternary (`condition ? true : false`) but instead recommends using inline if statements.
(`if (condition) true else false`). I don't feel very strongly about this, but I do tend to lean towards agreeing with
the Kotlin devs that it makes code a more readable.

### String Templating

### Function Equals

In Kotlin, you can set a function as equal to a value.

```kotlin
fun getCat() = "🐈"
```

This is equivalent to if I had written `return "🐈"` in the body of the function. I can also set this equal
to another function and pass the parameters.

```kotlin
fun getCat(id: String) = CatService.get(id)
```

### Variables

Kotlin has three main variables, `const val`, `val`, and `var`. `const val` is like final properties, they're final at
compile time. `val` is a property that cannot be reassigned, but can change. `var` is a property that can be reassigned.

Automatically, getters and setters are generated and can be set specifically like this:

```kotlin
var test get() = Config.get("value")
    set(value) = Config.write("value", value)
```

## Data Classes

Record classes are not the same

## Extension Functions

Extension functions are a big part of Kotlin, its own HTTP framework is mostly based around them. Extension functions
are when you extend a class by specifying it in front of your function method.

```kotlin
fun Application.module() {}
```

This function extends the Application class, and is now available like a method and just as `module()` in the current file.

My biggest use case for this was when I moved all my common API responses to a shared project that could be used for multiple
platforms. I used to have the database entity -> API response convertor functions on the companion objects of the data classes.
So, when I moved them to the common project, the database entity classes were no longer available and I had to move the
convertors to an extension function, like this:

```kotlin
fun Invite.Companion.fromEntity(entity: InviteEntity): Invite = Invite(
    id = entity.id.toString(),
    code = entity.code,
    // ...
    createdAt = entity.createdAt,
    usedAt = entity.usedAt
)
```

// Research: Java Interop
This extends the companion object so it's available like a static. I'll have more to say about those later on.

## Lambda Parameters

Kotlin loves lambdas, and the many DSLs<sup>[1]</sup> made in Kotlin use them in parameters. For example:

```kotlin
main {
    h1 {
        +"HTML DSL Example"
    }
    p {
        +"Hello! This is all inline functions!"
    }
}
```

...and in Gradle Kotlin configurations:

```kotlin
plugins {
    kotlin("jvm")
}

group = "site.remlit"
version = "0.0.1"

dependencies {}
```

I'm a big fan of these. In Aster, I have an event system that relies a lot on lambdas being passed to an event registry
where they're stored and then later called upon an event happening.

## Inline Functions

Inline functions are like regular functions, but often have lambda parameters. They can come with a performance benefit. 
In certain cases, it's more performant to inline the code than force an object to be created for the function. I say in 
certain cases because if you aren't careful, or have very large inline functions, you'll have excessive duplicates in 
compiled code that may be more efficient as a regular function.

A simple example inline function:

```kotlin
inline fun paragraph(text: () -> String) =
    "<p>${text()}</p>"

// can be used like
paragraph { "These small creatures inhabit Skyloft." }

// and results in "<p>These small creatures inhabit Skyloft.</p>"
```

Inline functions also are the only to support reified type parameters which allow you to inspect the passed type in your 
code. For example:

```kotlin
inline fun <reified T> speak() =
    when (T) {
        is Cat -> "Meow"
        is Dog -> "Bark"
    }
```

Where if the type parameter isn't reified...

```kotlin
inline fun <T> speak() =
    when (T) { // Error: Type parameter 'T' is not an expression.
        is Cat -> "Meow"
        is Dog -> "Bark"
    }
```

## Infix Functions

Infix functions are probably one of my favorite Kotlin features. They seem weird to begin with, but once you see how
they're used by others they feel very clever.

For example, Jetbrains Exposed (the Kotlin ORM) uses them to build query strings:

```kotlin
UserEntity
    .find {
        UserTable.host eq null and
        (UserTable.username neq "instance.actor") and
        (UserTable.createdAt lessThan TimeService.now())
    }
    .toList()
```

Another example is my math project I wrote for Set Theory:

```kotlin
println(a isDisjoint b)
println(a union (c complement u))
println(a intersection b intersection c)
println((h intersection k) diff j complement u)
println((a complement u) intersection (b complement u))
```

They let you write natural feeling code that just flows and is easily fit anywhere, and I love that.

## Trying to be Functional

Kotlin tries to appeal to people who like functional programming. At least a little bit.

## Coroutines

// Research

Only recently have I started really working with coroutines where I need to know everything about how they work. My first
impression wasn't positive though, I just thought "Oh, this is annoying." Now that I've actually had to use them, I
am alright with them. I like that they are more efficient with thread usage, which generally helps large scale servers
like Aster run butter than if they were in Java.

Coroutines start off at a dispatcher, and then the `suspend` (async) task is sent off to an available worker.

## Serialization

Kotlin serialization has been wonderful for my use case. I only had one hiccup when it came to ActivityPub's `object` property
which can be either an object or the ID of an object. For the most part, it's write a data class, throw on `@Serializable`,
and you're good to go. It's fast too, even with my weird rules and custom serializer.

## Multiplatform

I never really wanted to touch KMP, but in Aster I was able to move a bunch of my data classes for common objects compile
to a TypeScript library and be used in Kotlin. It's been nice to have types in the frontend exactly as they are in the
backend.

## Objects

One of my biggest annoyances with Kotlin is the lack of statics. Instead, it has objects and companion objects. Objects
work like a Java class with all statics would, and companion objects act like an embedded all static class.

So, these:

```kotlin
object Bookshelf {
    val books = mutableListOf<Book>()
    fun tipOver() {}
}
```

```kotlin
class Book {
    fun read() {}
    
    companion object {
	    fun create() {}
    }
} 
```

...are equivalent to these:

```java
class Bookshelf {
    public static List<Book> books = new List<Book>();
    public static void tipOver() {}
}
```

```java
class Book {
    public static void read() {}

    static class Companion {
        public static void create() {}
    }
}
```

I think the generated Companion subclass is unbelievably ugly and annoying.

This can be fixed with `@JvmStatic`. With this annotation, static methods are generated alongside the companion object.
Still, it's just a patch on default annoying behaviour. Having objects is not something I'm against, but if it's at the
cost of statics in classes, I'm not a big fan.

This is an issue that's been debated for years, has had multiple KEEP<sup>[2]</sup> discussions, and may or may not be
resolved eventually. For now, I'm fine with the language as is. This is my only major complaint, and it'd be less of a
thing for me if I was willing to make all my Service classes in Aster objects to begin with. It just feels weird to make
them objects. Overall, it is not a big deal.

## IDE Choices

Since Kotlin was made by Jetbrains, it's only really been supported in IntelliJ IDEA. It's had an Eclipse plugin for a
while, but it was basically unusable when I tested it. Recently, Jetbrains has been trying to fix this, and they've made
great progress. There's a [Visual Studio Code extension](https://github.com/Kotlin/kotlin-lsp) that I haven't used much
and also an extension for [Zed](https://zed.dev/extensions/kotlin) that works alright. I still use IDEA when I can,
even on my laptop where it's pretty terrible to use, but they're making progress.

## Honorable Mentions

### Cool Annotations

There's a bunch of built-in annotations for the JVM target that sound cool, but I never end up using them. One example of
that is `@JvmSynthetic` which makes it so only Kotlin code can use the annotated method. There's also `@JvmName`,
`@JvmField`, `@JvmDefault`, and others. Sometimes there's annotations to make up for missing features, like `@Throws`,
which is like Java's throws.

### Kotlin Scripting

Gradle

## The Android Language

Kotlin has way more potential than being just "The Android Language," and I hope it becomes more adopted. It's a wonderful
language to write, and has so many libraries and resources available just by having such strong Java interop. If you've been
interested in anything mentioned here, you should [try it out](https://kotlinlang.org/docs/jvm-get-started.html)!

## Footnotes

**1:** Domain Specific Language, referring to Kotlin's ability to make what feels like a custom language with inline and
infix functions.

**2:** Kotlin Evolution and Enhancement Process, the Kotlin JEP equivalent
